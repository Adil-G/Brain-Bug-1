<-----Page 0----->EECS 2021
Computer Organization
Fall 2015
The slides are based on the publisher slides
and contribution from Profs Amir Asif and
Peter Lian
The slides will be modified, annotated,
explained on the board, and sometimes
corrected in the class

Based on slides by the author and prof.
Mary Jane Irwin of PSU.

<-----Page 1----->Chapter Summary
n
n
n
n
n
n
n
n

Stored-program concept
Assembly language
Number representation
Instruction representation
Supporting procedures in hardware
MIPS addressing
Some real-world stuff
Fallacies and Pitfalls
Chapter 2 — Instructions: Language of the Computer — 2

<-----Page 2----->It is easy to see by formal-logical methods that there exist
certain [instruction sets] that are in abstract adequate to
control and cause the execution of any sequence of
operations . . . . The really decisive considerations from the
present point of view, in selecting an [instruction set], are
more of a practical nature:
simplicity of the equipment demanded by the [instruction
set], and the clarity of its application to the actually
important problems together with the speed of its handling
of those problems.
Burks, Goldstine, and von Neumann, 1947

Chapter 2 — Instructions: Language of the Computer — 3

<-----Page 3----->Marketing and management will not usually ask
for a combination of features, cost, and schedule
that are simultaneously realizable – count on that.
They will reliably ask for the impossible. … It’s a
very short step from using Moore’s Law to check
your road map to using it to dictate the road map.
Bob Colwell, The Pentium Chronicles

Chapter 2 — Instructions: Language of the Computer — 4

<-----Page 4----->Stored-Program Concept
n

n

n

n

n

Program instructions are stored in the
memory.
Every cycle, an instruction is read from the
memory (fetched).
The instruction is examined to decide what
to do (decode)
Then we perform the operation stated in
the instruction (execute)
Fetch-Decode-Execute cycle.
Chapter 2 — Instructions: Language of the Computer — 5

<-----Page 5----->n
n

The repertoire of instructions of a computer
Different computers have different
instruction sets
n

n

But with many aspects in common

Early computers had very simple
instruction sets
n

n

§2.1 Introduction

Instruction Set

Simplified implementation

Many modern computers also have simple
instruction sets RISC vs. CISC
Chapter 2 — Instructions: Language of the Computer — 6

<-----Page 6----->The MIPS Instruction Set
n
n

n

Used as the example throughout the book
Stanford MIPS commercialized by MIPS
Technologies (www.mips.com)
Large share of embedded core market
n

n

Applications in consumer electronics, network/storage
equipment, cameras, printers, …

Typical of many modern ISAs
n

See MIPS Reference Data tear-out card, and
Appendixes B and E

Chapter 2 — Instructions: Language of the Computer — 7

<-----Page 7----->The Four Design Principles
1.
2.
3.
4.

Simplicity favors regularity.
Smaller is faster.
Make the common case fast.
Good design demands good
compromises

Chapter 2 — Instructions: Language of the Computer — 8

<-----Page 8----->n

Add and subtract, three operands
n

n
n

Two sources and one destination

add a, b, c # a gets b + c
All arithmetic operations have this form
Design Principle 1: Simplicity favors
regularity
n
n

§2.2 Operations of the Computer Hardware

Arithmetic Operations

Regularity makes implementation simpler
Simplicity enables higher performance at
lower cost
Chapter 2 — Instructions: Language of the Computer — 9

<-----Page 9----->Arithmetic Example
n

C code:
f = (g + h) - (i + j);

n

Compiled MIPS code: (almost, this is not really assembly)
add t0, g, h
add t1, i, j
sub f, t0, t1

# temp t0 = g + h
# temp t1 = i + j
# f = t0 - t1

Chapter 2 — Instructions: Language of the Computer — 10

<-----Page 10----->n

n

Arithmetic instructions use register
operands
MIPS has a 32 32-bit register file
n
n
n

n

Assembler names
n
n

n

Use for frequently accessed data
Numbered 0 to 31
32-bit data called a “word”
$t0, $t1, …, $t9 for temporary values
$s0, $s1, …, $s7 for saved variables

§2.3 Operands of the Computer Hardware

Register Operands

Design Principle 2: Smaller is faster
n

c.f. main memory: millions of locations
Chapter 2 — Instructions: Language of the Computer — 11

<-----Page 11----->Chapter 2 — Instructions: Language of the Computer — 12

<-----Page 12----->Register Operand Example
n

C code:
f = (g + h) - (i + j);
n f, …, j in $s0, …, $s4

n

Compiled MIPS code: ( This is a real assembly)
add $t0, $s1, $s2
add $t1, $s3, $s4
sub $s0, $t0, $t1

Chapter 2 — Instructions: Language of the Computer — 13

<-----Page 13----->Memory Operands
n

Main memory used for composite data
n

n

To apply arithmetic operations
n
n

n

Load values from memory into registers
Store result from register to memory

Memory is byte addressed
n

n

Arrays, structures, dynamic data

Each address identifies an 8-bit byte

Words are aligned in memory
Address must be a multiple of 4
MIPS is Big Endian (The commercial MIPS, not
really, but in this course)
n Most-significant byte at least address of a word
n c.f. Little Endian: least-significant byte at least address
n

n

Chapter 2 — Instructions: Language of the Computer — 14

<-----Page 14----->Memory Access
Another way to put it
Big Endian:
leftmost byte is word address
Little Endian:
rightmost byte is word address
little endian
Bytes address
big endian

LSB
0

MSB
1

2

MSB

3
LSB

0

1

2

3

Aligned

Alignment restriction: requires
that objects fall on address that
is multiple of their size

Not
Aligned

Chapter 2 — Instructions: Language of the Computer — 15

<-----Page 15----->Big-Endian

Little-Endian

"Little-Endian" by R. S. Shaw - Own work. Licensed under Public Domain via
Commons - https://commons.wikimedia.org/wiki/File:LittleEndian.svg#/media/File:Little-Endian.svg

Chapter 2 — Instructions: Language of the Computer — 16

<-----Page 16----->Loading and Storing Bytes
n

MIPS provides special instructions to move bytes

lb

$t0, 1($s3)

#load byte from memory

sb

$t0, 6($s3)

#store byte to

n

memory

What 8 bits get loaded and stored?
n

load byte places the byte from memory in the
rightmost 8 bits of the destination register
n

n

what happens to the other bits in the register?

store byte takes the byte from the rightmost 8 bits of a
register and writes it to the byte in memory
n leaving the other bytes in the memory word
unchanged
Chapter 2 — Instructions: Language of the Computer — 17

<-----Page 17----->Example
n

Given the following code sequence and memory
state what is the state of the memory after
executing the code?
add
lb
sb

$s3, $zero, $zero
$t0, 1($s3)
q What value is left in $t0?
$t0, 6($s3)
Memory
$t0 = 0x00000090

24 0x 0 0 0 0 0 0 0 0

24

20

0x 0 0 0 0 0 0 0 0

20

16

0x 0 0 0 0 0 0 0 0

16

12

0x 1 0 0 0 0 0 1 0

12

8

0x 0 1 0 0 0 4 0 2

8

4

0x F F F F F F F F

4

0

0x 0 0 9 0 1 2 A 0

0

Data

q

What word is changed in Memory
and to what?
mem(4) = 0xFFFF90FF

What if the machine was little
Endian? $t0 = 0x00000012
mem(4) = 0xFF12FFFF Value not layout

q

?

Chapter 2 — Instructions: Language of the Computer — 18

