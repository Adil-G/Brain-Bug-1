<-----Page 0----->EECS 2021
Computer Organization
Fall 2015
The slides are based on the publisher slides
and contribution from Profs Amir Asif and
Peter Lian
The slides will be modified, annotated,
explained on the board, and sometimes
corrected in the class

Based on slides by the author and prof.
Mary Jane Irwin of PSU.

<-----Page 1----->

Branch to a labeled instruction if a
condition is true




beq rs, rt, L1




if (rs == rt) branch to instruction labeled L1;

bne rs, rt, L1




Otherwise, continue sequentially

§2.7 Instructions for Making Decisions

Conditional Operations

if (rs != rt) branch to instruction labeled L1;

j L1


unconditional jump to instruction labeled L1

Chapter 2 — Instructions: Language of the Computer — 2

<-----Page 2----->Conditional Operations




beq $s0, $s1, L1
bne $s0, $s1, L1
Instruction format

How to specify L1

op

rs

rt

constant or address

6 bits

5 bits

5 bits

16 bits

5

16

17

L1

4

16

17

L1

Chapter 2 — Instructions: Language of the Computer — 3

<-----Page 3----->Specifying Branch Destination







We could specify the memory location, but
that will require 32 bits ???
Can use a base register, the base register
is PC
Limits jumps to -215  215 -1
In reality, 00 is appended to the immediate
thus instructions (words not bytes)

Chapter 2 — Instructions: Language of the Computer — 4

<-----Page 4----->Branch destination

from the low order 16 bits of the branch instruction
16

sign-extend

offset
00

32

32 Add

PC
32

32
4

32

Add

32

32

branch dst
address
?

Chapter 2 — Instructions: Language of the Computer — 5

<-----Page 5----->Jump instruction


J Label
op

#go to label
26-bit address

6 bits

2



xxxx..xx

Again, concatenating 00 increase the
effective number to 28 + the left-most 4
bits of the PC (added to the PC)
Chapter 2 — Instructions: Language of the Computer — 6

<-----Page 6----->Jump instruction

from the low order 26 bits of the jump instruction
26

00
32

4

PC

Chapter 2 — Instructions: Language of the Computer — 7

<-----Page 7----->Branch Addressing


Branch instructions specify




Opcode, two registers, target address

Most branch targets are near branch




Forward or backward
op

rs

rt

constant or address

6 bits

5 bits

5 bits

16 bits

PC-relative addressing



Target address = PC + offset × 4
PC already incremented by 4 by this time
Chapter 2 — Instructions: Language of the Computer — 8

<-----Page 8----->Jump Addressing


Jump (j and jal) targets could be
anywhere in text segment




Encode full address in instruction
op

address

6 bits

26 bits

(Pseudo)Direct jump addressing


Target address = PC31…28 : (address × 4)

Chapter 2 — Instructions: Language of the Computer — 9

<-----Page 9----->Target Addressing Example


Loop code from earlier example


Assume Loop at location 80000

Loop: sll

$t1, $s3, 2

80000

0

0

19

9

4

0

add

$t1, $t1, $s6

80004

0

9

22

9

0

32

lw

$t0, 0($t1)

80008

35

9

8

0

bne

$t0, $s5, Exit 80012

5

8

21

2

19

19

1

addi $s3, $s3, 1

80016

8

j

80020

2

Exit: …

Loop

20000

80024

Chapter 2 — Instructions: Language of the Computer — 10

<-----Page 10----->Compiling If Statements


C code:
if (i==j) f = g+h;
else f = g-h;




f, g, … in $s0, $s1, …

Compiled MIPS code:
bne
add
j
Else: sub
Exit: …

i

j

$s3, $s4, Else
$s0, $s1, $s2
Exit
$s0, $s1, $s2
Assembler calculates addresses
Chapter 2 — Instructions: Language of the Computer — 11

<-----Page 11----->Compiling Loop Statements


C code:
while (save[i] == k) i += 1;




i in $s3, k in $s5, address of save in $s6

Compiled MIPS code:
Loop: sll
add
lw
save[i]
bne
addi
j
Exit: …

$t1,
$t1,
$t0,
$t0,
$s3,
Loop

$s3, 2
$t1, $s6
0($t1)
$s5, Exit
$s3, 1

Multiply i by 4
Address of
save[i]

Chapter 2 — Instructions: Language of the Computer — 12

<-----Page 12----->Basic Blocks


A basic block is a sequence of instructions
with



No embedded branches (except at end)
No branch targets (except at beginning)




A compiler identifies basic
blocks for optimization
An advanced processor
can accelerate execution
of basic blocks

Chapter 2 — Instructions: Language of the Computer — 13

<-----Page 13----->Compiling Case Statement
Memory
switch (k) {
case 0: h=i+j;
case 1: h=i+h;
case 2: h=i-j;



break; /*k=0*/
break; /*k=1*/
break; /*k=2*/

Assuming three sequential words in
memory starting at the address in $t4
have the addresses of the labels L0, L1,
and L2 and k is in $s2

L0:
L1:

L2:
Exit:

add
add
add
lw
jr
add
j
add
j
sub
. . .

$t1,
$t1,
$t1,
$t0,
$t0
$s3,
Exit
$s3,
Exit
$s3,

$s2, $s2
$t1, $t1
$t1, $t4
0($t1)

$t4

L2
L1
L0

$s0, $s1

#$t1 = 2*k
#$t1 = 4*k
#$t1 = addr of JumpT[k]
#$t0 = JumpT[k]
#jump based on $t0
#k=0 so h=i+j

$s0, $s3

#k=1 so h=i+h

$s0, $s1

#k=2 so h=i-j

Chapter 2 — Instructions: Language of the Computer — 14

<-----Page 14----->More Conditional Operations


Set dest to 1 if a condition is true




slt rd, rs, rt




if (rs < rt) rd = 1; else rd = 0;

slti rt, rs, constant




Otherwise, set to 0

if (rs < constant) rt = 1; else rt = 0;

Use in combination with beq, bne
slt $t0, $s1, $s2
bne $t0, $zero, L

# if ($s1 < $s2)
#
branch to L

Chapter 2 — Instructions: Language of the Computer — 17

<-----Page 15----->Branch Instruction Design



Why not blt, bge, etc?
Hardware for <, ≥, … slower than =, ≠







Combining with branch involves more work
per instruction, requiring a slower clock
All instructions penalized!

beq and bne are the common case
This is a good design compromise

Chapter 2 — Instructions: Language of the Computer — 18

<-----Page 16----->Signed vs. Unsigned




Signed comparison: slt, slti
Unsigned comparison: sltu, sltui
Example





$s0 = 1111 1111 1111 1111 1111 1111 1111 1111
$s1 = 0000 0000 0000 0000 0000 0000 0000 0001
slt $t0, $s0, $s1 # signed




–1 < +1  $t0 = 1

sltu $t0, $s0, $s1


# unsigned

+4,294,967,295 > +1  $t0 = 0
Chapter 2 — Instructions: Language of the Computer — 19

