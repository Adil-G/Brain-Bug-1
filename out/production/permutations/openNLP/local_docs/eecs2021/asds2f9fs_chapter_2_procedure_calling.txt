<-----Page 0----->EECS 2021
Computer Organization
Fall 2015
The slides are based on the publisher slides
and contribution from Profs Amir Asif and
Peter Lian
The slides will be modified, annotated,
explained on the board, and sometimes
corrected in the class

Based on slides by the author and prof.
Mary Jane Irwin of PSU.

<-----Page 1----->n

Steps required
1.

2.
3.
4.
5.

6.

Place parameters in a place where the
procedure can access them
Transfer control to procedure
Acquire storage (resources) for procedure
Perform procedure’s operations
Place result in a place where the caller can
access them.
Return to place of call

§2.8 Supporting Procedures in Computer Hardware

Procedure Calling

Chapter 2 — Instructions: Language of the Computer — 2

<-----Page 2----->Register Usage
n
n
n

$a0 – $a3: arguments (reg’s 4 – 7)
$v0, $v1: result values (reg’s 2 and 3)
$t0 – $t9: temporaries
n

n

$s0 – $s7: saved
n

n
n
n
n

Can be overwritten by callee
Must be saved/restored by callee

$gp: global pointer for static data (reg 28)
$sp: stack pointer (reg 29)
$fp: frame pointer (reg 30)
$ra: return address (reg 31)
Chapter 2 — Instructions: Language of the Computer — 3

<-----Page 3----->Procedure Call Instructions
n

Procedure call: jump and link
jal ProcedureLabel
n Address of following instruction put in $ra
n Jumps to target address

n

Procedure return: jump register
jr $ra
n Copies $ra to program counter
n Can also be used for computed jumps
n

e.g., for case/switch statements
Chapter 2 — Instructions: Language of the Computer — 4

<-----Page 4----->Leaf Procedure Example
n

C code:
int leaf_example (int g, h, i, j)
{ int f;
f = (g + h) - (i + j);
return f;
}
n Arguments g, …, j in $a0, …, $a3
n f in $s0 (hence, need to save $s0 on stack)
n Result in $v0
n Will need $t0, and $t1 in the calculation of f
Chapter 2 — Instructions: Language of the Computer — 5

<-----Page 5----->Stack
n
n
n

n

$sp

The best way to store registers is a stack
A stack is a first-in-last-out data structure
Stack pointer points to the last element in
the stack (or the first empty place).
Traditionally stack grows from higher to
lower addresses
used

used

empty

$t1
$t0

$sp

The stack
The stack after pushing $t1 $t0 and $s0

$s0
empty

Chapter 2 — Instructions: Language of the Computer — 6

<-----Page 6----->Procedure Call
int leaf_example (int g, h, i, j)
{ int f;
f = (g + h) - (i + j);
return f;
}

leaf_example:
addi
$sp, $sp, -12#adjust stack to make room for 3 items
sw
$t1, 8($sp) # push $t1
sw
$t0, 4($sp) # push $t0
sw
$s0, 0($sp) # push $s0

??

Save registers

Chapter 2 — Instructions: Language of the Computer — 7

<-----Page 7----->Procedure Call
add
add
sub

$t0, $a0, $a1
$t1, $a2, $a3
$s0, $t0, $t1

Do calculation
#$t0 = g+h
#$t1 = i+j
#$s0 = (g+h)-(i+j)

add

$v0, $s0, $zero

#put the result in $v0
put result in $v0

lw
add
sub
addi

$s0, 0($sp)
$t0, 4($sp)
$t1, 8($sp)
$sp, $sp, 12

jr

$ra

#restore $s0
#restore $t0
#restore $t1
#restore $sp

Clean up (remove data
from the stack)

#jump back to the calling routing

Return control to caller
Chapter 2 — Instructions: Language of the Computer — 8

<-----Page 8----->Leaf Procedure Example
n

MIPS code:
leaf_example:
addi $sp, $sp, -4
sw
$s0, 0($sp)
add $t0, $a0, $a1
add $t1, $a2, $a3
sub $s0, $t0, $t1
add $v0, $s0, $zero
lw
$s0, 0($sp)
addi $sp, $sp, 4
jr
$ra

Save $s0 on stack

Procedure body
Result
Restore $s0
Return

Chapter 2 — Instructions: Language of the Computer — 9

<-----Page 9----->Non-Leaf Procedures
n
n

Procedures that call other procedures
For nested call, caller needs to save on the
stack:
n
n

n

Its return address
Any arguments and temporaries needed after
the call

Restore from the stack after the call

Chapter 2 — Instructions: Language of the Computer — 10

<-----Page 10----->Non-Leaf Procedure Example
n

C code:
int fact (int n)
{
if (n < 1) return f;
else return n * fact(n - 1);
}
n Argument n in $a0
n Result in $v0

Chapter 2 — Instructions: Language of the Computer — 11

<-----Page 11----->Non-Leaf Procedure Example
n

MIPS code:
fact:
addi
sw
sw
slti
beq
addi
addi
jr
L1: addi
jal
lw
lw
addi
mul
jr

$sp,
$ra,
$a0,
$t0,
$t0,
$v0,
$sp,
$ra
$a0,
fact
$a0,
$ra,
$sp,
$v0,
$ra

$sp, -8
4($sp)
0($sp)
$a0, 1
$zero, L1
$zero, 1
$sp, 8
$a0, -1
0($sp)
4($sp)
$sp, 8
$a0, $v0

#
#
#
#

adjust stack for 2 items
save return address
save argument
test for n < 1

#
#
#
#
#
#
#
#
#
#

if so, result is 1
pop 2 items from stack
and return
else decrement n
recursive call
restore original n
and return address
pop 2 items from stack
multiply to get result
and return

Chapter 2 — Instructions: Language of the Computer — 12

<-----Page 12----->Local Data on the Stack

Points to the
1st word in the
procedure
frame

n

Local data allocated by callee
n

n

e.g., C automatic variables

Procedure frame (activation record)
n
n
n

Used by some compilers to manage stack storage
Fixed, does not change during the function execution
A stable base register to address for local memory reference
Chapter 2 — Instructions: Language of the Computer — 13

<-----Page 13----->Memory Layout
n
n

Text: program code
Static data: global
variables
n

n

n

Dynamic data: heap
n

n

e.g., static variables in C,
constant arrays and strings
$gp initialized to address
allowing ±offsets into this
segment
E.g., malloc in C, new in
Java

Stack: automatic storage
Chapter 2 — Instructions: Language of the Computer — 14

<-----Page 14----->n

Byte-encoded character sets
n

ASCII: 128 characters
n

n

Latin-1: 256 characters
n

n

95 graphic, 33 control
ASCII, +96 more graphic characters

§2.9 Communicating with People

Character Data

Unicode: 32-bit character set
n
n
n

Used in Java, C++ wide characters, …
Most of the world’s alphabets, plus symbols
UTF-8, UTF-16: variable-length encodings
Chapter 2 — Instructions: Language of the Computer — 15

<-----Page 15----->String Copy Example
n

C code (naïve):
Null-terminated string
void strcpy (char x[], char y[])
{ int i;
i = 0;
while ((x[i]=y[i])!='\0')
i += 1;
}
n Addresses of x, y in $a0, $a1
n i in $s0
n

Chapter 2 — Instructions: Language of the Computer — 16

<-----Page 16----->String Copy Example
n

MIPS code:
strcpy:
addi
sw
add
L1: add
lbu
add
sb
beq
addi
j
L2: lw
addi
jr

$sp,
$s0,
$s0,
$t1,
$t2,
$t3,
$t2,
$t2,
$s0,
L1
$s0,
$sp,
$ra

$sp, -4
0($sp)
$zero, $zero
$s0, $a1
0($t1)
$s0, $a0
0($t3)
$zero, L2
$s0, 1
0($sp)
$sp, 4

#
#
#
#
#
#
#
#
#
#
#
#
#

adjust stack for 1 item
save $s0
i = 0
addr of y[i] in $t1
$t2 = y[i]
addr of x[i] in $t3
x[i] = y[i]
exit loop if y[i] == 0
i = i + 1
next iteration of loop
restore saved $s0
pop 1 item from stack
and return

Chapter 2 — Instructions: Language of the Computer — 17

